;argument:  the list representation of the tree
;return type: a list of nodes in DFS order 
;check whether it's an atom, if it is, make it a list; else, do the DFS on the first part and the remaining part
; and append them together
(defun DFS (tree)
  (cond ( (NULL tree) NIL)
	( (atom tree) (list tree))
	( t (append (DFS (car tree)) (DFS (cdr tree))))
	)
  )


;two arguments: the list representation of the tree and the max depth allowed to search
;return type: a list of nodes in DFS order
;if the depth < 0 , return nil; else, depth-- on the (car tree) and append it with the remaining part
(defun DLS (tree depth)
  (cond ( (NULL tree) NIL)
        ( (< depth 0) NIL)
        ( (atom tree) (list tree))
	(t (append (DLS (car tree) (- depth 1)) (DLS (cdr tree) depth)))
	)
  )
	  
;two arguments: the list representation of the tree and the max depth allowed to search
; return type: a list of nodes in DFS order
; use the DLS function, append the lists generated by DLS
(defun DFID (tree depth)
  (cond ( (NULL tree) NIL)
	( (< depth 0) NIL)
	(t (append (DFID tree (- depth 1)) (DLS tree depth)))
	)
  )


; FINAL-STATE takes a single argument (S), the current state, and returns T if
; it is the goal state (3 3 NIL) and NIL otherwise.
; just judge whether s is equal to (3 3 NIL)
(defun final-state (s)
  (cond ( (equal s '(3 3 NIL)) t)
	( t NIL)
	)
  )

 ;NEXT-STATE returns the state that results from applying an operator to the
; current state. It takes three arguments: the current state (S), a number of
; missionaries to move (M), and a number of cannibals to move (C). It returns a
; list containing the state that results from moving that number of missionaries
; and cannibals from the current side of the river to the other side of the
; river. If applying this operator results in an invalid state (because there
; are more cannibals than missionaries on either side of the river, or because
; it would move more missionaries or cannibals than are on this side of the
; river) it returns NIL.
; the trick is that if there are 0 missionaries, there can be cannibals, so we need to judge this
; situation specifically
(defun next-state (s m c)
  ( cond ( (< (first s) m) NIL)
	 ( (< (second s) c) NIL)
	 ( (and (< (- (first s) m) (- (second s) c)) (not (= 0 (- (first s) m))))  NIL)
	 ( (and (< (- (+ 3 m) (first s)) (- (+ 3 c) (second s))) (not (= (+ (- 3 (first s)) m) 0))) NIL)
	 ( t (list (list (- (+ 3 m) (first s)) (- (+ 3 c) (second s)) (not (third s)))))
	 )
  )


; SUCC-FN returns all of the possible legal successor states to the current
; state. It takes a single argument (S), which encodes the current state, and
; returns a list of states that can be reached by applying legal operators to
; the current state.
; as long as m+c<=2, we can try all possible combinations
(defun succ-fn(s)
  (append (next-state s 0 1) (next-state s 0 2) (next-state s 1 1) (next-state s 1 0) (next-state s 2 0))
  )


; MULT-DFS is a helper function for SINGLE-DFS. It takes three arguments: the
; path from the initial state to the current state (PATH), the legal successor
; states to the last state on PATH (STATES), and the depth (DEPTH). PATH is a
; first-in first-out list of states; that is, the first element is the initial
; state for the current search and the last element is the most recent state
; explored. MULT-DFS does a single depth-first iteration to the given depth on
; each element of STATES in turn. If any of those searches reaches the final
; state, MULT-DFS returns the complete path from the initial state to the goal
; state. Otherwise, it returns NIL.
; first search the first possible state, if feasbiel, return it;
; else, do the mult-dfs on the remaining states
(defun mult-dfs (states path depth)
  ( cond ( (NULL states) NIL)
	 ( (not (equal (single-dfs (first states) path depth) NIL)) (single-dfs (first states) path depth))
	 ( t (mult-dfs (cdr states) path depth))
	 )
  )


; SINGLE-DFS does a single depth-first iteration to the given depth. It takes
; three arguments: a state (S), the path from the initial state to S (PATH), and
; the depth (DEPTH). If S is the initial state in our search, PATH should be
; NIL. It performs a depth-first search starting at the given state. It returns
; the path from the initial state to the goal state, if any, or NIL otherwise.
; if depth = 0, it's the deepest level;
; else if s is the final state, return the path
; else, do the mult-dfs
(defun single-dfs (s path depth)
  (cond ( ( and (= depth 0) (not (final-state s))) NIL)
	( ( final-state s) (append path (list s)))
	( t (mult-dfs (succ-fn s) (append path (list s)) (- depth 1)))
	)
  )


;; ID-DFS is the top-level function. It takes two arguments: an initial state (S)
; and a search depth (DEPTH). ID-DFS performs a series of depth-first
; iterations, starting from the given depth until a solution is found. It
; returns the path from the initial state to the goal state. The very first call
; to ID-DFS should use depth = 0.
;recursively do single-dfs with increasing depth
(defun id-dfs (s depth)
  (cond ( (NULL (single-dfs s NIL depth)) (id-dfs s (+ depth 1)))
	( t (single-dfs s NIL depth))
	)
  )




